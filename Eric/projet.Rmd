---
title: "projet.Rmd"
author: "Eric"
date: "21 janvier 2019"
output:
  html_document:
    toc: true
    toc_depth: 2
    toc_float: TRUE
    number_sections: true
    theme: paper # ou default, cerulean, journal, flatly, darkly, readable, spacelab, united, cosmo, lumen, paper, sandstone, simplex, and yeti
    highlight: tango # ou  default, tango, pygments, kate, monochrome, espresso, zenburn, haddock, and textmate
    code_folding: hide
---

# ETAPE 1

```{r}
setwd = (".")
getwd()
```

## LECTURE DES JEUX DE DONNEE

```{r}
donnee1 = read.csv (file = "./../data/placenta_edragon_91mol.csv", header = T, sep = ";", dec = ".")
donnee2 = read.csv (file = "./../data/placenta_MOE_2D_192.csv", header = T, dec = ".", sep =";")
```

## ON VERIFIE SI LES NOMS DES LIGNES SONT CORRECTES

```{r}
nom_col1 = donnee1[,"NOM"]
nom_col2 = donnee2[, "Noms"]
comp = nom_col1%in%nom_col2
comp
```
**NON**,  `%in%` vérifie que ce sont les mêmes nom, mais pas l'ordre or les deux sont importants. En effet, pour vérifier, tu peux essayer :

```{r, eval = F}
nom_col2 <- sort(nom_col2, decreasing=T)
comp = nom_col1%in%nom_col2
comp
```

ce qui donne un vecteur à `TRUE` aussi. Ce n'est donc pas la bonne fonction.

=> on laisse tomber pour l'instant.


## ON INSERE LA DONNEE CLAIRANCE DANS LE FICHIER EDRAGON
```{r}
clairance = donnee2[,"CI"]
donneefin = data.frame(donnee1, clairance)
```


## DIMENSION DE LA TABLE
```{r}
dim(donneefin)
```
-> Les dimensions de la table sont `r ncol(donnefin)` descripteurs et `r nrow(donnefin)` composés.


## LES ENTETES DES LIGNES
```{r}
namecol = colnames(donneefin)
```



# ETAPE 2

## VALEURS ABERRANTES DANS CI

```{r}
hist(donneefin[, "clairance"])
box = boxplot (donneefin [,"clairance"])
box
boxmax = box$out
```

On remarque une valeur aberrante (1,57)
On extrait la valeur dans boxmax

-> On transforme le 1.57 en NA

```{r}
donneefin$clairance[donneefin$clairance == boxmax] <- NA
```

```{r}
donneefin = na.omit(donneefin)
donneefin$clairance
```


## DONNEE MANQUANTE (-999)

-> On compte le nombre de -999

### Methode 1: Sans convertir -999 en NA

```{r, eval=F}
suma = apply(donneefin, 2, function(x) sum(x==-999))
```

-> On supprimme les colonnes ne contenant que des -999 ()

```{r, eval=F}
donneefin2 = Filter(function(x) length(unique(x))>1, donneefin)
```



### Methode 2: On remplace les -999 par NA

```{r}
donneefin[donneefin == -999] <- NA
```

-> On compte le nombre de NA dans chaque colonne et on enleve les colonnes avec seulement des NA

```{r}
sum_Na = apply (donneefin, 2, function(x) sum (is.na(x)))

sum_non_NA = which(sum_Na ==0)

donneefin = donneefin[ ,sum_non_NA]
```

-> Ou on aurait pu faire : 

```{r, eval=F}
donneefinbis = donneefin[ , !apply( donneefin , 2 , function(donneefin)       all(is.na(donneefin)))]
```

-

NOTE : Cependant je n'ai pas reussi ? supprimer les NA present dans plus de n cases dans une colonne


-> On ?limine les 2 premieres colonnes pour effectuer la moyenne de chaque colonne

```{r}
donneemoy = donneefin2bis[ ,3:796]
```

-> On fait la moyenne de chaque colonne

```{r}
moyfin2 = apply(donneemoy, 2, function(x) mean(x, na.rm=T))
```

-> On remplace les NA par les moyennes de la colonne respectives

```{r}
donneefin3 = apply (donneemoy, 2, function(x) x[is.na (x)]) <- moyfin2
donneefin3
```


3) DONNEE CONSTANTES

-> On verifie les variances des colonnes contenant des valeurs constantes

```{r}

```



# Sauvegarde des données
`write.table` écrire au format texte
`save`sauvegarder au format .Rdata, (`load`)

