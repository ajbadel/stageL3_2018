---
title: "Presentation 3"
author: "Marc XU"
date: "1 mars 2019"
output:
  revealjs::revealjs_presentation:
    center: yes
    highlight: kate
    theme: league
    transition: zoom
---
# Neuron Network {data-background="pikachu.png"}

```{r message = FALSE}
library(neuralnet)
library(nnet)
library(mclust)
library(caret)
library(ROCR)
library(knitr)
library(MLmetrics) # calcul de F1.Score
library(mltools) # calcul du coeff de correl. de Matthiew

knitr::opts_chunk$set(
  fig.width = 8, fig.height = 6, 
  fig.path = 'figures/iris_',
  fig.align = "center", 
  size = "tiny", 
  echo = FALSE, 
  eval = TRUE, 
  warning = FALSE, 
  message = FALSE, 
  results = TRUE, 
  comment = "")
```

```{r echo = FALSE}
set.seed(245)
table(iris$Species)
```
# Données IRIS

## Les données IRIS

```{r}
head(iris)
```

## Résumés des données
```{r}
data("iris")
summary(iris)
```

## Visualisation des données (plot)
```{r}
plot(iris, col = iris$Species)
```

## Visualisation des données (boxplot)
```{r}
par(mfrow=c(2,2))
for (i in 1:4) {
  titre.boxplot <- paste("boxplot de :", colnames(iris)[i])
  boxplot(iris[,i] ~ iris[,5])
  title(titre.boxplot)
}
par(mfrow=c(1,1))
```

## Visualisation des données (histogramme)
```{r}
par(mfrow=c(4,3))
for (i in 1:4) {
  titre.histogramme <- paste("Histogramme de :", colnames(iris)[i])
  by(iris[,i], iris[,5], hist, main = titre.histogramme, breaks = 15, xlab = "cm")
}
par(mfrow=c(1,1))
```

```{r}
set.seed(24)

seto = as.numeric(iris$Species == "setosa")
versi = as.numeric(iris$Species == "versicolor")
virgi = as.numeric(iris$Species == "virginica")
```

```{r}
data.iris = data.frame(iris[,c(1:4)], seto, versi, virgi)
#data.seto = data.frame(iris[,c(1:4)], seto)
#data.versi = data.frame(iris[,c(1:4)], versi)
#data.virgi = data.frame(iris[,c(1:4)], virgi)
```

```{r}
set.seed(24)
formule = as.formula(seto + versi + virgi ~ Sepal.Length + Sepal.Width + Petal.Length + Petal.Width)

reseau1 = neuralnet(formule, data = data.iris, hidden = c(1,1))
resultat_matrice1 <- as.data.frame(reseau1$result.matrix)
```

# Prediction
```{r, results = 'hide'}
set.seed(24)
ind.app <- sample(1:nrow(iris), 100)
iris.app <- iris[ind.app,]
iris.test <- iris[-ind.app,]
iris.nn <- nnet::nnet(Species ~ ., data = iris, subset = ind.app,
                      size = 1)
temp_train <- subset(iris, select = c(1:4))
prediction = predict(iris.nn, iris)
```

## 

### Matrice de confusion
```{r}
matrice_confusion.ex = data.frame(CONDITION_POSITIVE = c("True Positive (TP)", "False Negative (FN)"), CONDITION_NEGATIVE = c("False Positive (FP)", "False Negative (TN)"), row.names = c("PREDICT_POSITIVE (P)","PREDICT_NEGATIVE (N)"))
kable(matrice_confusion.ex)

predit = prediction
observe = data.iris[,c(5:7)]

# La fonction pour la matrice de confusion
matrice_confusion = function (observation, prediction) {
  resultats1 = sapply(X = data.frame(observe = observation,
                                     predit = prediction),
                      FUN = round, digits=1)
  resultats.df = data.frame(resultats1)
  attach(resultats.df)
  table.resultat = table(
    observe = resultats.df$observe,
    prediction =  resultats.df$predit)
  return(table.resultat)
}
```

## Formule mathématiques (1)

Taux d'erreur (accuracy) : ACC = $\frac{TP+TN} {TP+TN+FP+TF}$

Sensibilité (sensibility) : TPR = $\frac{TP} {TP+FN}$

Specificité (specificity) : TNR = $\frac{TN} {TN+FP}$

## Formule mathématiques (2)

F1 score : F1 = $\frac{2*TP} {2*TP+FP+FN}$

Coefficient de corrélation de Matthews : MCC =  

$\frac{TP*TN-FP*FN} {((TP+FP)(TP+FN)(TN+FP)(TN+FN))^{-1}}$

```{r}
# La fonction accuracy
acc = function (resultats) {
  acc_cal = (resultats[1,1] + resultats[2,2]) /
    (resultats[1,1] + resultats[1,2] + resultats[2,1] + resultats[2,2])
  return(acc_cal)
}

# La fonction sensibilité
sens = function (resultats) {
  sens_cal = resultats[1,1] / (resultats[1,1] + resultats[2,1])
  return(sens_cal)
}

# La fonction spécifité
spec = function (resultats) {
  spec_cal = resultats[2,2] /(resultats[1,2] + resultats[2,2])
  return(spec_cal)
}

# La fonction F1_Score
scor = function (resultats) {
  scor_cal = (2 * resultats[1,1]) / (2 * resultats[1,1] + resultats[1,2] + resultats[2,1])
  return(scor_cal)
}

# La fonction ccm
ccm1 = function (resultats) {
  ccm1_cal = (resultats[1,1] * resultats[2,2] - resultats[1,2] * resultats[2,1]) / (sqrt((resultats[1,1]+resultats[1,2]) * (resultats[1,1]+resultats[2,1]) * (resultats[2,2]+resultats[1,2]) *  (resultats[2,2]+resultats[2,1])))
  return(ccm1_cal)
}
```

# Le modèle SETOSA

## Le modèle SETOSA (1)

Matrice de confusion de l'espèce SETOSA
```{r}
kable(matrice_confusion(observe[,1], predit[,1]))

```

## Le modèle SETOSA (2)
```{r, eval = FALSE}
# Calculé directement par les fonctions de RStudio
matrice.setosa = confusionMatrix(table.resultat.seto)
acc.seto = matrice.setosa$overall["Accuracy"]
sen.seto = matrice.setosa$byClass["Sensitivity"]
spe.seto = matrice.setosa$byClass["Specificity"]
F1S_seto = F1_Score(resultats.df.seto$observe, resultats.df.seto$prediction, positive= NULL)
mcc.seto = mcc(actuals = resultats.df.seto$observe, preds = resultats.df.seto$prediction)
```

```{r, message = FALSE}
Paramètres = c("Accurancy", "Sensibilité", "Specifité", "F1_Score", "Coeff. de cor. de Matthew")
Valeurs.seto = c(acc(matrice_confusion(observe[,1], predit[,1])),
                 sens(matrice_confusion(observe[,1], predit[,1])),
                 spec(matrice_confusion(observe[,1], predit[,1])),
                 scor(matrice_confusion(observe[,1], predit[,1])),
                 ccm1(matrice_confusion(observe[,1], predit[,1])))
kable(data.frame(Paramètres, Valeurs.seto))
```

# Le modèle VERSICOLOR

## Le modèle VERSICOLOR (1)

Matrice de confusion de l'espèce VERSICOLOR
```{r}
kable(matrice_confusion(observe[,2], predit[,2]))
```

## Le modèle VERSICOLOR (2)

```{r}
Valeurs.versi = c(acc(matrice_confusion(observe[,2], predit[,2])),
                 sens(matrice_confusion(observe[,2], predit[,2])),
                 spec(matrice_confusion(observe[,2], predit[,2])),
                 scor(matrice_confusion(observe[,2], predit[,2])),
                 ccm1(matrice_confusion(observe[,2], predit[,2])))
kable(data.frame(Paramètres, Valeurs.versi))
```

# Le modèle VIRGINICA

## Le modèle VIRGINICA (1)

Matrice de confusion de l'espèce VIRGINICA
```{r}
kable(matrice_confusion(observe[,3], predit[,3]))
```

## Le modèle VIRGINICA (2)

```{r}
Valeurs.virgi = c(acc(matrice_confusion(observe[,3], predit[,3])),
                 sens(matrice_confusion(observe[,3], predit[,3])),
                 spec(matrice_confusion(observe[,3], predit[,3])),
                 scor(matrice_confusion(observe[,3], predit[,3])),
                 ccm1(matrice_confusion(observe[,3], predit[,3])))
kable(data.frame(Paramètres, Valeurs.virgi)) 
```

# Courbe ROC

```{r, eval = FALSE}
roc1 = function (resultats) {
  roc1_cal = 1 - (resultats[1,1] / (resultats[1,1] + resultats[2,2]))
  return(roc1_cal)
}

roc2 = function (resultats) {
  roc2_cal = 1 - (resultats[2,1] / (resultats[2,1] + resultats[2,1]))
  return(roc2_cal)
}
```

```{r}
prob = compute(reseau1, data.iris[, -c(5:7)])
prob.result = prob$net.result

rocfun = function (prob.result.entry, data.iris.entry) {
  for (i in 1:10) {
    pred[i] = prediction(prob.result.entry, data.iris.entry)
    perf = performance(pred[i], "sens", "spec")
    return(perf)
  }
}

aucfun = function(prob.result.entry, data.iris.entry) {
  pred = prediction(prob.result.entry, data.iris.entry)
  auc = performance(pred, "auc")@y.values[[1]]
  return(auc)
}
```

## Courbe ROC (1)

SETOSA  
```{r}
perf.seto = rocfun(prob.result[,1], data.iris$seto)
plot(perf.seto, colorize = TRUE, main = "ROC apprentissage")

```

## Courbe ROC (2)

VERSICOLOR
```{r}
perf.versi = rocfun(prob.result[,2], data.iris$versi)
plot(perf.versi, colorize = TRUE, main = "ROC apprentissage")
```

## Courbe ROC (3)

VIRGINICA
```{r}
perf.virgi = rocfun(prob.result[,3], data.iris$virgi)
plot(perf.virgi, colorize = TRUE, main = "ROC apprentissage")
```

## Valeurs AUC

```{r}
Auc = c("AUC setosa", "AUC versicolor", "AUC virginica")
Calcul_AUC = c(aucfun(prob.result[,1], data.iris$seto),
               aucfun(prob.result[,2], data.iris$versi),
               aucfun(prob.result[,3], data.iris$virgi))
kable(data.frame(Auc, Calcul_AUC))
```

# Bibliographie

## Sites consultés
https://www.calvin.edu/~rpruim/courses/s341/S17/from-class/MathinRmd.html (formules mathématiques)
