---
title: "Neuralnet Presentation 4"
author: "Marc XU"
date: "1 mars 2019"
output:
  revealjs::revealjs_presentation:
    center: yes
    highlight: kate
    theme: league
    transition: zoom
---
# Neuron Network {data-background="pikachu.png"}

```{r message = FALSE}
library(neuralnet)
library(nnet)
library(mclust)
library(caret)
library(ROCR)
library(knitr)
library(e1071)
library(MLmetrics) # calcul de F1.Score
library(mltools) # calcul du coeff de correl. de Matthiew

knitr::opts_chunk$set(
  fig.width = 8, fig.height = 6, 
  fig.path = 'figures/iris_',
  fig.align = "center", 
  size = "tiny", 
  echo = FALSE, 
  eval = TRUE, 
  warning = FALSE, 
  message = FALSE, 
  results = TRUE, 
  comment = "")
```

```{r}
set.seed(245)
matrice_confusion.ex = data.frame(CONDITION_POSITIVE = c("True Positive (TP)", "False Negative (FN)"), CONDITION_NEGATIVE = c("False Positive (FP)", "False Negative (TN)"), row.names = c("PREDICT_POSITIVE (P)","PREDICT_NEGATIVE (N)"))

#predit = predict(iris.nn, newdata = iris.test)
#observe = data.iris[,c(5:7)]

# La fonction pour la matrice de confusion
matrice_confusion = function (observation, prediction) {
  resultats1 = sapply(X = data.frame(observe = observation,
                                     predit = prediction),
                      FUN = round, digits=1)
  resultats.df = data.frame(resultats1)
  attach(resultats.df)
  table.resultat = table(
    observe = resultats.df$observe,
    prediction =  resultats.df$predit)
  return(table.resultat)
}
```

```{r}
# Les fonctions0

# La fonction accuracy
acc = function (resultats) {
  return(sum(diag(resultats)) / sum(resultats))
}

# La fonction erreur
err = function (resultats) {
  return(1 - (sum(diag(resultats)) / sum(resultats)))
}

# La fonction sensibilité
sens = function (resultats) {
  if (nrow(resultats) >= 2) {
    return(resultats[2,2] / (resultats[2,2] + resultats[1,2]))
  } else {
    return(NA)
  }
}

# La fonction spécifité
spec = function (resultats) {
  if (nrow(resultats) >= 2) {
    return(resultats[1,1] /(resultats[2,1] + resultats[1,1]))
  } else {
    return(NA)
  }
}

# La fonction F1_Score
scor = function (resultats) {
  return((2 * resultats[1,1]) / (2 * resultats[1,1] + resultats[1,2] + resultats[2,1]))
}

# La fonction ccm
ccm1 = function (resultats) {
  return((resultats[1,1] * resultats[2,2] - resultats[1,2] * resultats[2,1]) / (sqrt((resultats[1,1]+resultats[1,2]) * (resultats[1,1]+resultats[2,1]) * (resultats[2,2]+resultats[1,2]) *  (resultats[2,2]+resultats[2,1]))))
}
```

```{r}
table(iris$Species)
```
# Données IRIS

## Les données IRIS

```{r}
data("iris")
kable(head(iris))
```

## Résumés des données
```{r}
summary(iris)
```

## Visualisation des données (plot)
```{r}
plot(iris, col = iris$Species)
```

## Visualisation des données (boxplot)
```{r}
par(mfrow=c(2,2))
for (i in 1:4) {
  titre.boxplot <- paste("boxplot de :", colnames(iris)[i])
  boxplot(iris[,i] ~ iris[,5])
  title(titre.boxplot)
}
par(mfrow=c(1,1))
```

## Visualisation des données (histogramme)
```{r}
par(mfrow=c(4,3))
for (i in 1:4) {
  titre.histogramme <- paste("Histogramme de :", colnames(iris)[i])
  by(iris[,i], iris[,5], hist, main = titre.histogramme, breaks = 15, xlab = "cm")
}
par(mfrow=c(1,1))
```

```{r}
seto = as.numeric(iris$Species == "setosa")
versi = as.numeric(iris$Species == "versicolor")
virgi = as.numeric(iris$Species == "virginica")
```

```{r}
#data.iris = data.frame(iris[,c(1:4)], seto, versi, virgi)
#data.seto = data.frame(iris[,c(1:4)], seto)
#data.versi = data.frame(iris[,c(1:4)], versi)
#data.virgi = data.frame(iris[,c(1:4)], virgi)
```

```{r}
formule = as.formula(seto + versi + virgi ~ Sepal.Length + Sepal.Width + Petal.Length + Petal.Width)
```

# Prediction des SETOSA
```{r}
ind.app <- sample(1:nrow(iris), 100)
iris.app <- iris[ind.app,]
iris.test <- iris[-ind.app,]
```

```{r}
# Les fonctions
prediction2 = function (reseau) {
  realite2 = as.numeric(reseau$response)
  prediction2 = reseau$net.result
  results <- data.frame(actual = realite2, prediction = prediction2)
  names(results) <- c("Realité", "Prédiction")
  return(results)
}
perfection2 = function(matrice) {
  acc.app <- acc(matrice)
  err.app <- err(matrice)
  perf.app <- c(acc.app, err.app)
  names(perf.app) <- c("accuracy", "erreur")
  return(perf.app)
}
```

```{r}
formule = as.formula(seto + versi + virgi ~ Sepal.Length + Sepal.Width + Petal.Length + Petal.Width)
reseau1 = neuralnet(formule, data = data.iris, hidden = c(1,1))

predire = predict(reseau1, newdata = iris.app, type = "class")
confiance.seto <- table(predire[,1], iris.app$Species, dnn = c("predit", "observe"))
confiance.versi <- table(predire[,2], iris.app$Species, dnn = c("predit", "observe"))
confiance.virgi <- table(predire[,3], iris.app$Species, dnn = c("predit", "observe"))

knitr::kable(confiance.seto)
knitr::kable(confiance.versi)
knitr::kable(confiance.virgi)

```

## Prédiction dans l'échantillon d'apprentissage
```{r}
reseau2.seto.app = neuralnet(Species == "setosa" ~ Sepal.Length + Sepal.Width + Petal.Length + Petal.Width, data = iris.app, linear.output = FALSE)
prediction.2.seto.app = prediction2(reseau2.seto.app)
matrice.seto.app = matrice_confusion(prediction.2.seto.app[,1], prediction.2.seto.app[,2])
knitr::kable(matrice.seto.app)
knitr::kable(perfection2(matrice.seto.app))
```

## Les taux (échantillon d'apprentissage)
```{r}
Paramètres = c("Taux bon", "Taux d'erreur","Sensibilité", "Specifité", "F1_Score", "Coeff. de cor. de Matthew")
Valeurs = c(acc(matrice_confusion(prediction.2.seto.app[,1], prediction.2.seto.app[,2])),
            err(matrice_confusion(prediction.2.seto.app[,1], prediction.2.seto.app[,2])),
            sens(matrice_confusion(prediction.2.seto.app[,1], prediction.2.seto.app[,2])),
            spec(matrice_confusion(prediction.2.seto.app[,1], prediction.2.seto.app[,2])),
            scor(matrice_confusion(prediction.2.seto.app[,1], prediction.2.seto.app[,2])),
            ccm1(matrice_confusion(prediction.2.seto.app[,1], prediction.2.seto.app[,2])))
kable(data.frame(Paramètres, Valeurs))
```

## Prédiction dans l'échantillon test
```{r}
reseau2.seto.test = neuralnet(Species == "setosa" ~ Sepal.Length + Sepal.Width + Petal.Length + Petal.Width, data = iris.test, linear.output = FALSE)
prediction.2.seto.test = prediction2(reseau2.seto.test)
matrice.seto.test = matrice_confusion(prediction.2.seto.test[,1], prediction.2.seto.test[,2])
knitr::kable(matrice.seto.test)
knitr::kable(perfection2(matrice.seto.test))
```

## Les taux (échantillon test)
```{r}
Valeurs = c(acc(matrice_confusion(prediction.2.test[,1], prediction.2.test[,2])),
            err(matrice_confusion(prediction.2.test[,1], prediction.2.test[,2])),
            sens(matrice_confusion(prediction.2.test[,1], prediction.2.test[,2])),
            spec(matrice_confusion(prediction.2.test[,1], prediction.2.test[,2])),
            scor(matrice_confusion(prediction.2.test[,1], prediction.2.test[,2])),
            ccm1(matrice_confusion(prediction.2.test[,1], prediction.2.test[,2])))
kable(data.frame(Paramètres, Valeurs))
```

# Prédiction des VERSICOLOR

## Prédiction dans l'échantillon d'apprentissage
```{r}
reseau2.versi.app = neuralnet(Species == "versicolor" ~ Sepal.Length + Sepal.Width + Petal.Length + Petal.Width, data = iris.app, linear.output = FALSE)
reseau2.versi.app$net.result
prediction.2.versi.app = prediction2(reseau2.versi.app)
prediction.2.versi.app[,2] = ifelse(prediction.2.seto.app[,2] >= 0.5, 0, 1) 
matrice.versi.app = matrice_confusion(prediction.2.versi.app[,1], prediction.2.versi.app[,2])
knitr::kable(matrice.versi.app)
knitr::kable(perfection2(matrice.versi.app))
```

## Les taux (échantillon d'apprentissage)

```{r}
Valeurs = c(acc(matrice_confusion(prediction.2.versi.app[,1], prediction.2.versi.app[,2])),
            err(matrice_confusion(prediction.2.versi.app[,1], prediction.2.versi.app[,2])),
            sens(matrice_confusion(prediction.2.versi.app[,1], prediction.2.versi.app[,2])),
            spec(matrice_confusion(prediction.2.versi.app[,1], prediction.2.versi.app[,2])),
            scor(matrice_confusion(prediction.2.versi.app[,1], prediction.2.versi.app[,2])),
            ccm1(matrice_confusion(prediction.2.versi.app[,1], prediction.2.versi.app[,2])))
kable(data.frame(Paramètres, Valeurs))
```

##  Prédiction dans l'échantillon test
```{r}
reseau2.versi.test = neuralnet(Species == "versicolor" ~ Sepal.Length + Sepal.Width + Petal.Length + Petal.Width, data = iris.test, linear.output = FALSE)
prediction.2.versi.test = prediction2(reseau2.versi.test)
prediction.2.versi.test[,2] = ifelse(prediction.2.seto.test[,2] >= 0.5, 0, 1) 
matrice.versi.test = matrice_confusion(prediction.2.versi.test[,1], prediction.2.versi.test[,2])
knitr::kable(matrice.versi.test)
knitr::kable(perfection2(matrice.versi.test))
```

## Les taux (échantillon test)
```{r}
Valeurs = c(acc(matrice_confusion(prediction.2.versi.test[,1], prediction.2.versi.test[,2])),
            err(matrice_confusion(prediction.2.versi.test[,1], prediction.2.versi.test[,2])),
            sens(matrice_confusion(prediction.2.versi.test[,1], prediction.2.versi.test[,2])),
            spec(matrice_confusion(prediction.2.versi.test[,1], prediction.2.versi.test[,2])),
            scor(matrice_confusion(prediction.2.versi.test[,1], prediction.2.versi.test[,2])),
            ccm1(matrice_confusion(prediction.2[,1], prediction.2[,2])))
kable(data.frame(Paramètres, Valeurs))
```

# Prédiction des VIRGINICA

## Prédiction dans l'échantillon d'apprentissage
```{r}
reseau2.virgi.app = neuralnet(Species == "virginica" ~ Sepal.Length + Sepal.Width + Petal.Length + Petal.Width, data = iris.app, linear.output = FALSE)
prediction.2.virgi.app = prediction2(reseau2.virgi.app)
matrice.virgi.app = matrice_confusion(prediction.2.virgi.app[,1], prediction.2.virgi.app[,2])
knitr::kable(matrice.virgi.app)
knitr::kable(perfection2(matrice.virgi.app))
```

## Les taux (échantillon d'apprentissage)
```{r}
Valeurs = c(acc(matrice_confusion(prediction.2.virgi.app[,1], prediction.2.virgi.app[,2])),
            err(matrice_confusion(prediction.2.virgi.app[,1], prediction.2.virgi.app[,2])),
            sens(matrice_confusion(prediction.2.virgi.app[,1], prediction.2.virgi.app[,2])),
            spec(matrice_confusion(prediction.2.virgi.app[,1], prediction.2.virgi.app[,2])),
            scor(matrice_confusion(prediction.2.virgi.app[,1], prediction.2.virgi.app[,2])),
            ccm1(matrice_confusion(prediction.2.virgi.app[,1], prediction.2.virgi.app[,2])))
kable(data.frame(Paramètres, Valeurs))
```

## Prédiction dans l'échantillon test
```{r}
reseau2.virgi.test = neuralnet(Species == "virginica" ~ Sepal.Length + Sepal.Width + Petal.Length + Petal.Width, data = iris.test, linear.output = FALSE)
prediction.2.virgi.test = prediction2(reseau2.virgi.test)
matrice = matrice_confusion(prediction.2.virgi.test[,1], prediction.2.virgi.test[,2])
knitr::kable(matrice)
knitr::kable(perfection2(matrice))
```

## Les taux (échantillon test)
```{r}
Valeurs = c(acc(matrice_confusion(prediction.2.virgi.test[,1], prediction.2.virgi.test[,2])),
            err(matrice_confusion(prediction.2.virgi.test[,1], prediction.2.virgi.test[,2])),
            sens(matrice_confusion(prediction.2.virgi.test[,1], prediction.2.virgi.test[,2])),
            spec(matrice_confusion(prediction.2.virgi.test[,1], prediction.2.virgi.test[,2])),
            scor(matrice_confusion(prediction.2.virgi.test[,1], prediction.2.virgi.test[,2])),
            ccm1(matrice_confusion(prediction.2.virgi.test[,1], prediction.2.virgi.test[,2])))
kable(data.frame(Paramètres, Valeurs))
```

# Courbe ROC

## Courbe ROC (1)

SETOSA  
```{r}
iris.app.prob.setosa <- prediction.2.seto.app[,2]
iris.app.setosa <- iris.app$Species == "setosa"
seuil <- seq(0, 1, length.out = 100)
vsens <- rep(NA, 100)
vspe <- rep(NA, 100)
for (i in 1:100) {
  iris.pred <- iris.app.prob.setosa >= seuil[i]
  vsens[i] <- sens(table(iris.pred, iris.app.setosa))
  vspe[i] <- spec(table(iris.pred, iris.app.setosa))
}
plot(1-vspe, vsens, type = "l", col = "red",
     xlab = "FPR = 1-Spe", ylab = "TPR = Sens")
```

VERSICOLOR  
```{r}

iris.app.prob.versicolor <- prediction.2.versi.app[,2]
iris.app.versicolor <- iris.app$Species == "versicolor"
seuil <- seq(0, 1, length.out = 100)
vsens <- rep(NA, 100)
vspe <- rep(NA, 100)
for (i in 1:90) {
  iris.pred <- iris.app.prob.versicolor >= seuil[i]
  vsens[i] <- sens(table(iris.pred, iris.app.versicolor))
  vspe[i] <- spec(table(iris.pred, iris.app.versicolor))
}
plot(1-vspe, vsens, type = "l", col = "red",
     xlab = "FPR = 1-Spe", ylab = "TPR = Sens")
```

VIRGINICA  
```{r}

iris.app.prob.virginica <- prediction.2.virgi.app[,2]
iris.app.virginica <- iris.app$Species == "virginica"
seuil <- seq(0, 1, length.out = 100)
vsens <- rep(NA, 100)
vspe <- rep(NA, 100)
for (i in 1:90) {
  iris.pred <- iris.app.prob.virginica >= seuil[i]
  vsens[i] <- sens(table(iris.pred, iris.app.virginica))
  vspe[i] <- spec(table(iris.pred, iris.app.virginica))
}
plot(1-vspe, vsens, type = "l", col = "red",
     xlab = "FPR = 1-Spe", ylab = "TPR = Sens")
```
